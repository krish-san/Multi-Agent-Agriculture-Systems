{
  "master": {
    "tasks": [
      {
        "id": 26,
        "title": "Setup Backend Foundation and API Gateway",
        "description": "Initialize the project structure, set up a FastAPI backend, configure the database connection (SQLite for dev, PostgreSQL for prod), and establish the basic API gateway for service coordination.",
        "details": "Create a new Git repository. Set up a Python virtual environment. Install FastAPI, Uvicorn, and SQLAlchemy. Create initial directories for agents, services, and models. Define the base Pydantic models for requests and responses. Configure CORS and basic logging.\n<info added on 2025-08-13T18:31:40.572Z>\n‚úÖ LEVERAGING EXISTING AGENTWEAVER FRAMEWORK\n\nAfter examining the codebase, we already have a sophisticated AgentWeaver framework that provides:\n\nüèóÔ∏è **Already Available Infrastructure:**\n- ‚úÖ FastAPI backend with health checks and CORS (`main.py`)\n- ‚úÖ LangGraph-based SupervisorNode for agent orchestration (`supervisor.py`)\n- ‚úÖ Redis integration for state management (`redis_config.py`)\n- ‚úÖ WebSocket support for real-time updates\n- ‚úÖ React frontend with agent dashboard (`frontend/`)\n- ‚úÖ Base agent architecture with capabilities system (`base_agent.py`)\n- ‚úÖ Agent registry and task management system\n\nüéØ **Task 26 Strategy - Build Upon Existing Foundation:**\nInstead of creating from scratch, we'll:\n1. **Extend AgentWeaver** with agriculture-specific agents\n2. **Add agricultural data models** to the existing core models\n3. **Create specialized agents** that inherit from BaseWorkerAgent\n4. **Integrate multilingual support** into the existing framework\n5. **Add agricultural data sources** to the existing API structure\n\n‚úÖ **Context7 LangChain Documentation Retrieved:**\n- Multi-agent orchestration patterns using LangGraph\n- Agent tool integration and execution patterns\n- State management for complex workflows\n- Migration guidance from legacy AgentExecutor to LangGraph\n\nüöÄ **Next Actions:**\n1. Create agricultural data models (crop, weather, soil, etc.)\n2. Build Router Agent that inherits from BaseWorkerAgent\n3. Create first agricultural specialist agents (Crop Selection, Pest Forecaster)\n4. Add multilingual NLP preprocessing capabilities\n5. Integrate with government data APIs\n\nThis approach leverages existing infrastructure while focusing on agricultural domain specifics.\n</info added on 2025-08-13T18:31:40.572Z>",
        "testStrategy": "Run the FastAPI server locally. Use an API client like Postman or curl to hit a health check endpoint (e.g., `/health`) and verify a 200 OK response. Unit test the initial database connection logic.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Multi-Agent Router System (Orchestrator)",
        "description": "Develop the central orchestrator using CrewAI or LangChain to parse natural language queries, classify intent, and route them to the appropriate specialist agents.",
        "details": "Choose between CrewAI and LangChain for orchestration. Implement a 'Router' agent responsible for intent classification using few-shot learning with an LLM (e.g., Llama 3 via API). The router should be able to handle parallel and sequential agent execution plans. It must also synthesize responses from multiple agents.",
        "testStrategy": "Unit test the intent classification with a set of sample queries in English, Hindi, and code-switched text. Verify that queries like 'Kab irrigate karun aur finance kaise mile?' are correctly routed to mock 'Irrigation' and 'Finance' agent tasks. Test the response synthesizer with mock agent outputs.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Develop Basic Web Dashboard UI",
        "description": "Create a responsive web dashboard using Streamlit or React that includes a chat interface for user queries and a display area for agent responses.",
        "details": "Set up a Streamlit application. Implement a chat input component and a message history display. Use WebSockets to communicate with the FastAPI backend for real-time interaction. Design a simple layout to show agent routing and final synthesized responses.",
        "testStrategy": "Manually test the UI by sending a message and ensuring it appears in the chat history. Connect to the backend and verify that a query sent from the UI is received by the FastAPI server. Check that responses from the backend are displayed correctly in the UI.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "review",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Gemini-based Multilingual Query Processing",
        "description": "Leverage Gemini AI's native multilingual capabilities to process Hindi, English, and code-switched queries directly, simplifying the pre-processing pipeline.",
        "status": "done",
        "dependencies": [
          27
        ],
        "priority": "high",
        "details": "Instead of a separate pre-processing pipeline with text normalization and translation, use Gemini AI directly. Craft a system prompt for the orchestrator (Router Agent from Task 27) that instructs Gemini to understand the user's query regardless of the language (Hindi, English, Hinglish) and to process it for intent classification. This approach removes the need for the 'Indic NLP Library' or external translation APIs.",
        "testStrategy": "Create a test suite with a diverse set of Hindi, English, and Hinglish queries. Verify that the Gemini-powered orchestrator correctly understands and classifies the intent of these queries without an explicit pre-processing step. Test edge cases with mixed scripts, dialects, and complex code-switching to ensure robust performance.",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Develop Crop Selection Agent (Agent 1)",
        "description": "Build the agent to recommend optimal crop varieties based on location, soil, and weather, and provide yield predictions.",
        "details": "Integrate ICRISAT and data.gov.in datasets for crop varieties and historical yields. Develop a simple yield prediction model using scikit-learn (e.g., RandomForestRegressor). The agent's toolset should include functions to query these datasets and models based on user-provided location and soil type.",
        "testStrategy": "Unit test the agent's tools with mock location data. Create integration tests where the agent is invoked by the orchestrator with a query like 'Suggest a crop for my farm in Punjab'. Verify the response includes variety names, expected yield, and risk factors.",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Develop Pest Outbreak Forecaster Agent (Agent 2)",
        "description": "Create the agent to identify pests from descriptions, forecast outbreaks, and recommend treatments. This task focuses on text-based identification and forecasting.",
        "details": "Build a knowledge base from PlantNet and Kisan Call Center data, storing it in a FAISS vector store for retrieval. Implement a time-series model (e.g., LSTM using TensorFlow/PyTorch) for outbreak forecasting based on weather data. The agent will use RAG to answer pest queries.",
        "testStrategy": "Test the RAG system with text descriptions of common pests (e.g., 'white flies on my cotton plant'). Validate the treatment recommendations against agricultural guidelines. Test the forecasting model with historical weather data to see if it predicts known outbreak periods.",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Develop Irrigation Scheduling Agent (Agent 4)",
        "description": "Build the agent to calculate crop water requirements and create optimal irrigation schedules using meteorological and soil data.",
        "details": "Implement the Penman-Monteith equation using the `sympy` library to calculate evapotranspiration (ET). Integrate with the IMD weather API for real-time temperature, humidity, and wind speed data. The agent will take crop type and growth stage as input to generate a daily/weekly watering schedule.",
        "testStrategy": "Validate the Penman-Monteith calculation against known benchmarks. Test the weather API integration for reliability. Run an end-to-end test with a query like 'When should I water my wheat crop?' and verify the output is a coherent schedule.",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Integrate Phase 1 Agents with Orchestrator",
        "description": "Connect the Crop Selection, Pest Forecaster, and Irrigation agents to the central router and ensure seamless end-to-end query processing for the initial MVP scope.",
        "details": "Register the three developed agents and their tools with the CrewAI/LangChain orchestrator. Refine the router's intent detection prompts to accurately distinguish between queries for these three domains. Test complex queries that require multiple agents.",
        "testStrategy": "Perform integration testing with queries like 'My wheat crop looks stressed, what pest could it be and how much water does it need?'. Verify that the orchestrator correctly calls the Pest and Irrigation agents and synthesizes their responses into a single, helpful answer.",
        "priority": "high",
        "dependencies": [
          28,
          30,
          31,
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Setup Satellite Data Acquisition Pipeline (PoC)",
        "description": "Implement a proof-of-concept pipeline to automatically acquire, preprocess, and store satellite imagery metrics like NDVI for specific locations.",
        "details": "Use the Sentinel Hub API (free tier) to fetch Sentinel-2 imagery for given coordinates. Use Rasterio and GDAL libraries to process the raster data. Calculate NDVI using NumPy. Store the processed metric (e.g., average NDVI for a farm area) in the database, linked to a location and date.",
        "testStrategy": "Write a script that takes latitude/longitude as input and successfully downloads an image tile. Verify the NDVI calculation is correct by comparing with a known online tool. Check that the resulting data is correctly stored in the database.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Integrate Satellite Data into Agent Decisions",
        "description": "Enhance the Irrigation and Crop Selection agents to use processed satellite data (NDVI, soil moisture) as part of their decision-making process.",
        "details": "Create a new tool for agents to query the satellite data from the database based on a user's farm location. Modify the Irrigation agent's logic to adjust water recommendations based on soil moisture data. Modify the Crop Selection agent to use NDVI for assessing current land health.",
        "testStrategy": "Test the Irrigation agent with and without satellite data to see if the recommendations change logically. Manually verify that the agent is fetching and using the correct NDVI/soil moisture values for a given location during a query.",
        "priority": "medium",
        "dependencies": [
          33,
          34
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Develop Finance and Policy Agent (Agent 3)",
        "description": "Build the agent to simulate eligibility for agricultural loans and government subsidies using a rule-based engine.",
        "details": "Gather data on schemes like PM-KISAN and agricultural loans from Open Budgets India and bank websites. Implement a rule-based engine using Python logic or a library like `durable_rules`. The agent will ask the user clarifying questions (e.g., land size, crop type) to determine eligibility.",
        "testStrategy": "Create test cases for different farmer profiles (e.g., small-scale, medium-scale, different states). Verify that the agent correctly identifies applicable schemes and calculates eligibility based on the defined rules. Compare results against official government eligibility checkers.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Develop Market Timing Agent (Agent 5)",
        "description": "Create the agent to forecast commodity prices and recommend optimal selling times using time-series analysis.",
        "details": "Integrate with the UPAg market price API to fetch historical price data for various commodities and mandis. Implement a price forecasting model using Prophet or ARIMA from the `statsmodels` library. The agent's output should include a price forecast chart and confidence intervals.",
        "testStrategy": "Train the model on historical data and test its forecasting accuracy on a hold-out set. Test the API integration to ensure it can fetch data for different crops and markets. Verify the agent provides a clear recommendation (e.g., 'Sell now', 'Wait 2 weeks').",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Develop Harvest Planning Agent (Agent 6)",
        "description": "Build the agent to determine optimal harvest dates by modeling crop calendars and integrating weather forecasts.",
        "details": "Create a database of crop growth stages and typical durations (crop calendars). Integrate a weather forecast API to assess risks (e.g., rain) around the potential harvest window. The agent will combine the crop calendar with weather data to recommend a specific harvest date or week.",
        "testStrategy": "Test with different crops and planting dates. Verify that the agent's recommended harvest date aligns with the crop calendar. Introduce a mock weather forecast with rain and check if the agent adjusts its recommendation to avoid it.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Develop Input Materials Advisor (Agent 7)",
        "description": "Build the agent to recommend optimal and cost-effective fertilizers, seeds, and pesticides.",
        "details": "Use the PuLP library for optimizing fertilizer combinations based on soil test results and nutrient requirements. Integrate with a chemical database like PubChemPy for pesticide information. Create a simple scoring algorithm for seed quality based on certification data.",
        "testStrategy": "Unit test the PuLP optimization with a sample soil report to ensure it generates a cost-effective fertilizer mix. Test the pesticide recommendation tool to verify it suggests appropriate and safe products for a given pest and crop.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Implement Computer Vision for Pest ID",
        "description": "Enhance the Pest Forecaster agent with a computer vision model to identify pests from user-submitted photos.",
        "details": "Fine-tune a lightweight CV model like MobileNetV2 on a pest image dataset (e.g., from PlantVillage). Expose this model as a tool that the Pest agent can use. The tool will take an image URL or a base64 encoded image and return a list of potential pests with confidence scores.",
        "testStrategy": "Test the image processing endpoint with a set of test images of common pests. Measure the model's identification accuracy (precision/recall). Integrate with the agent and verify that a query with an image correctly triggers the vision tool.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "todo",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement Explainable AI (XAI) and Confidence Scoring",
        "description": "Modify all agents to provide explanations for their recommendations, including cited sources and a confidence score.",
        "details": "Update the base agent class or prompt templates to require a 'reasoning' and 'confidence_score' field in the output. For RAG-based agents, the reasoning should include the source documents. For model-based agents, it should explain the key features that influenced the decision. Confidence scores can be derived from model probabilities or rule-based certainty.",
        "testStrategy": "Review the output of each agent for a variety of queries. Verify that every recommendation is accompanied by a clear explanation and a numerical confidence score (e.g., 0.85). Check that cited sources are relevant and accurate.",
        "priority": "medium",
        "dependencies": [
          33,
          36,
          37,
          38,
          39
        ],
        "status": "todo",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Implement User Onboarding and Profile Management",
        "description": "Create the user flow for new user onboarding, including language selection, location input, and farm details collection.",
        "details": "Develop a multi-step form in the web UI for onboarding. Create backend endpoints and database tables to store user profiles, including farm location (GeoJSON), primary crops, and language preference. This data should be loaded into the agent context for personalized responses.",
        "testStrategy": "Manually go through the onboarding flow as a new user. Check the database to ensure the profile is created correctly. Start a new chat session and verify that the agent context is pre-populated with the user's farm location and preferences.",
        "priority": "low",
        "dependencies": [
          28
        ],
        "status": "todo",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "End-to-End MVP System Testing",
        "description": "Conduct comprehensive testing of the fully integrated 7-agent system. Focus on performance, accuracy, and user experience across all features.",
        "details": "Develop a test plan covering all major use cases from the PRD. Perform load testing to check response times under concurrent user load (target <10s for complex queries). Recruit a small group of internal testers (including agricultural domain experts) to validate the quality of recommendations.",
        "testStrategy": "Execute the test plan and log all bugs and issues. Measure key metrics: query response time, intent classification accuracy, and recommendation relevance (as rated by experts). The system passes when critical/high bugs are resolved and performance targets are met.",
        "priority": "high",
        "dependencies": [
          35,
          40,
          41,
          42
        ],
        "status": "todo",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Basic WhatsApp Integration (PoC)",
        "description": "Set up a proof-of-concept WhatsApp bot that forwards user queries to the main backend system and returns the response.",
        "details": "Use the WhatsApp Business API via a provider like Twilio. Create a simple webhook endpoint on the FastAPI backend to receive incoming messages. This endpoint will pass the query to the agent orchestrator and send the final synthesized response back to the user via the WhatsApp API.",
        "testStrategy": "Send a message to the WhatsApp bot number. Verify the message is received by the backend. Check that the agent's response is sent back to the user on WhatsApp. Test basic text queries and image submissions for pest identification.",
        "priority": "low",
        "dependencies": [
          43
        ],
        "status": "todo",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Setup CI/CD and MVP Deployment Infrastructure",
        "description": "Configure a basic Continuous Integration/Continuous Deployment pipeline and prepare the infrastructure for MVP deployment on a cloud provider.",
        "details": "Create a GitHub Actions workflow to automatically run tests on every push. Write a Dockerfile for the backend application. Use a simple platform like Heroku or Vercel for web UI deployment and a small cloud VM (e.g., AWS EC2, GCP Compute Engine) for the backend. Set up basic monitoring and logging (e.g., AWS CloudWatch).",
        "testStrategy": "Push a small change to the repository and verify that the CI pipeline runs successfully. Manually trigger a deployment to the staging environment. Access the deployed application URL and confirm it is operational.",
        "priority": "medium",
        "dependencies": [
          43
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Expand Satellite Data Integration to Core Agricultural Agents",
        "description": "Enhance the Pest Management, Finance, Market Timing, Harvest Planning, and Input Materials agents by integrating satellite-derived data like NDVI, soil moisture, and weather for more accurate and timely recommendations.",
        "details": "This task involves extending the satellite data capabilities established in Task 35 to a wider range of agents. The existing satellite data tool should be generalized to fetch not only NDVI and soil moisture but also relevant weather data (e.g., temperature, precipitation, humidity) from a suitable API.\n\nImplementation per agent:\n- **Pest Management Agent**: Modify the agent to use weather data for improved pest outbreak forecasting. Integrate NDVI data to help users identify and scout stressed areas of a field, which could indicate early-stage infestations.\n- **Finance Agent**: Enhance financial models to use historical and current NDVI data as a proxy for yield estimation, improving the accuracy of revenue forecasts and loan risk assessments.\n- **Market Timing Agent**: Augment the agent's logic to analyze regional NDVI data to estimate crop supply trends. Use weather forecasts to predict potential harvest or logistics disruptions that could impact market prices.\n- **Harvest Planning Agent**: Use time-series NDVI data to monitor crop maturity and field uniformity, enabling recommendations for the optimal harvest window. The agent should also use short-term weather forecasts to advise against harvesting during adverse conditions.\n- **Input Materials Agent (from Task 39)**: Refine the agent's recommendations by using soil moisture data to optimize the timing of fertilizer application and prevent runoff. Use NDVI maps to suggest variable-rate application strategies, targeting nutrients to specific areas of need.",
        "testStrategy": "1. **Unit Test Data Tool**: Verify the generalized satellite data tool can successfully fetch NDVI, soil moisture, and weather data for a given set of coordinates and date range.\n2. **Pest Agent Test**: Provide the agent with weather data known to favor a specific pest and confirm it generates a high-risk alert. Provide a field with a known low-NDVI spot and verify the agent suggests scouting that specific area.\n3. **Finance Agent Test**: Run a financial forecast for a farm with high historical NDVI and another with low historical NDVI. Verify the projected yield and revenue are appropriately higher for the former.\n4. **Market Timing Test**: Simulate a scenario with high regional NDVI (indicating high supply) and verify the agent's market timing advice adjusts accordingly (e.g., sell earlier).\n5. **Harvest Planning Test**: Input NDVI data showing non-uniform crop maturity and check that the agent recommends a staggered harvesting approach. Input a 3-day forecast with rain and verify the agent advises against harvesting on the rainy days.\n6. **Input Materials Agent Test**: Query for fertilizer advice with low soil moisture data and verify the agent adjusts its recommendation. Provide a field with variable NDVI and confirm the agent suggests a variable-rate application plan.",
        "status": "in-progress",
        "dependencies": [
          34,
          35,
          39
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Enhance Market Timing Agent with Satellite Data Integration",
        "description": "Integrate satellite data into the Market Timing Agent to enable NDVI-based yield forecasting, environmental risk assessment, and satellite-adjusted price predictions for more accurate recommendations.",
        "details": "This task enhances the Market Timing Agent (Task 37) by incorporating satellite-derived metrics. Key implementation steps include:\n1. **Yield Forecasting Model**: Develop a model that uses time-series NDVI data from the acquisition pipeline (Task 34) to forecast crop yields for a user's specific location.\n2. **Risk Assessment Module**: Analyze satellite data (e.g., soil moisture, temperature anomalies) to quantify environmental risks like drought or heat stress that could impact supply.\n3. **Price Model Enhancement**: Modify the agent's existing price forecasting model (e.g., Prophet/ARIMA) to use the new yield forecasts and risk assessments as input features, creating a more robust supply-demand model.\n4. **Confidence Interval Calculation**: Ensure the agent's final recommendation ('Sell', 'Wait') is accompanied by a statistically derived confidence level (target 95%) based on the prediction intervals of the enhanced model.",
        "testStrategy": "1. **Yield Model Validation**: Test the yield forecasting model against a hold-out dataset of historical NDVI and known yield data. Ensure the Mean Absolute Percentage Error (MAPE) is below an acceptable threshold.\n2. **Price Model Backtesting**: Compare the forecasting accuracy (RMSE/MAPE) of the satellite-enhanced price model against the baseline model from Task 37 on historical data. The new model must demonstrate a significant improvement.\n3. **Scenario Testing**: Create test cases with high-risk environmental data (e.g., simulated drought) and verify the agent adjusts its price predictions and recommendations appropriately.\n4. **End-to-End Integration Test**: For a given location, confirm the agent successfully queries the generalized satellite data tool (from Task 46), processes it through the yield and price models, and returns a coherent recommendation with the correct confidence score.",
        "status": "done",
        "dependencies": [
          37,
          34,
          46
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Market Timing Agent Satellite Integration - COMPLETED",
        "description": "Successfully integrated satellite data into Market Timing Agent for advanced yield forecasting and market intelligence",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implement Satellite Data Visualization Components in React Frontend",
        "description": "Create interactive React components for the web dashboard to visualize real-time satellite data, including NDVI, soil moisture, and weather, helping farmers understand their field conditions.",
        "details": "This task involves building the frontend components to render satellite data on an interactive map. \n1. **API Integration**: A new API endpoint must be defined and consumed from the FastAPI backend. This endpoint should accept geographic coordinates (or a field ID) and return time-series data for NDVI, soil moisture, and relevant weather metrics.\n2. **Mapping Component**: Implement a central `FieldMap` component using a library like Leaflet or Mapbox GL JS. This component will display the user's field boundaries.\n3. **Data Layers**: Create toggleable overlay layers for each data type:\n    - **NDVI Layer**: Display NDVI data as a color-coded heatmap (e.g., red-yellow-green) over the field map to indicate vegetation health.\n    - **Soil Moisture Layer**: Display soil moisture as a separate color-graded overlay (e.g., shades of blue).\n    - **Weather Layer**: Visualize current and forecasted weather using icons (e.g., sun, rain clouds) on the map and a detailed panel showing temperature, precipitation, and wind speed.\n4. **State Management**: Use a state management solution like Redux Toolkit or Zustand to manage API loading states, errors, and the visibility of different data layers.\n5. **UI Controls**: Add UI controls for selecting date ranges and toggling the visibility of the data layers.",
        "testStrategy": "1. **Component Unit Tests**: Use Jest and React Testing Library to test individual components. Verify that the `FieldMap` and layer control components render correctly with mock data.\n2. **API Mocking**: Use Mock Service Worker (MSW) to mock the satellite data API endpoint. Write tests to ensure the components correctly handle loading, success, and error states during data fetching.\n3. **Interaction Testing**: Simulate user actions, such as clicking a layer toggle button or changing the date range. Verify that the correct API calls are triggered and the component state updates accordingly.\n4. **End-to-End Manual Verification**: Once integrated, manually test the full feature on a staging environment. Select a field, and confirm that all data layers (NDVI, soil moisture, weather) load and display correctly on the map. Test the responsiveness of the components on various screen sizes.",
        "status": "pending",
        "dependencies": [
          28,
          46
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Optimize React Web Dashboard for Mobile Responsiveness",
        "description": "Refactor the existing React web dashboard to ensure it is fully responsive and provides a touch-friendly, intuitive user experience on mobile devices, catering to the primary user base of Indian farmers on smartphones.",
        "details": "1. **Responsive Layout Implementation**: Utilize CSS media queries, Flexbox, and/or CSS Grid to create a fluid layout that adapts to various screen sizes, from small smartphones to tablets. Key components like the chat interface, agent response display, and data visualization areas must be refactored to stack vertically and resize gracefully.\n2. **Touch-Friendly UI Controls**: Increase the size and spacing of all interactive elements, including buttons, links, and form inputs, to meet mobile accessibility standards (e.g., minimum 44x44px touch targets). Replace hover-dependent interactions (like tooltips) with touch-friendly alternatives like tap-to-reveal modals or popovers.\n3. **Simplified Mobile Navigation**: Implement a collapsible navigation menu (e.g., a 'hamburger' menu) or a bottom navigation bar for core application sections. The goal is to reduce clutter and make primary features easily accessible with one hand.\n4. **Component-Specific Refactoring**: \n   - **Chat Interface (from Task 28)**: Ensure the chat input is always visible when the on-screen keyboard appears and that message history scrolls smoothly.\n   - **Map Visualizations (from Task 49)**: Verify that map interactions like pinch-to-zoom and panning are smooth on touch devices. Ensure map controls and legends are legible and usable on small screens.\n5. **Performance Optimization**: Optimize asset delivery for mobile networks. This includes compressing images, lazy-loading off-screen components using `React.lazy` and Suspense, and code-splitting the application bundle to reduce initial load times.",
        "testStrategy": "1. **Emulator and Device Toolbar Testing**: Use browser developer tools (e.g., Chrome Device Toolbar) to simulate a wide range of mobile viewports (iPhone, Samsung Galaxy, Pixel) and test the responsive layout breakpoints.\n2. **Real Device Testing**: Conduct manual testing on a variety of physical Android and iOS devices to verify touch accuracy, gesture responsiveness (especially for maps), and performance in real-world conditions. Check for any OS-specific rendering issues.\n3. **Performance Auditing**: Run Google Lighthouse audits with a 'Mobile' device and 'Simulated Throttling' setting to measure key performance metrics like First Contentful Paint (FCP) and Time to Interactive (TTI). Aim for a performance score above 80.\n4. **Functional Verification**: Perform end-to-end tests on mobile to ensure all core functionalities‚Äîsending queries, receiving agent responses, interacting with data visualizations, and user onboarding‚Äîwork as expected without regressions.\n5. **Usability Heuristics**: Evaluate the interface against mobile usability principles. Ensure text is readable, navigation is intuitive, and interactive elements provide clear feedback upon touch.",
        "status": "pending",
        "dependencies": [
          28,
          49
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Refactor Hardcoded Values to Environment-Based Configuration",
        "description": "Centralize all hardcoded configuration values, such as API endpoints, database paths, and system thresholds, into a unified system that uses environment variables and configuration files for different environments (development, production).",
        "details": "The goal is to eliminate hardcoded values from the codebase to improve security, flexibility, and maintainability across different deployment environments.\n\n1. **Backend Configuration (FastAPI):**\n   - Introduce `pydantic-settings` to manage application settings.\n   - Create a central `app/config.py` module with a `Settings` class that loads variables from environment files.\n   - Create an `.env.example` file in the root directory listing all required environment variables (e.g., `DATABASE_URL`, `CORS_ORIGINS`, `LOAN_AMOUNT_MAX`).\n   - Create a `.env` file for local development (this file should be in `.gitignore`).\n   - Refactor the database connection logic from Task #26 to use `settings.DATABASE_URL`.\n   - Refactor the CORS middleware setup to use `settings.CORS_ORIGINS`, which should be a comma-separated string.\n   - Identify and move all magic numbers and hardcoded strings related to financial limits (e.g., loan amounts, crop costs) and system thresholds from agent logic into the settings module.\n\n2. **Frontend Configuration (React):**\n   - Utilize Create React App's built-in support for environment variables.\n   - Create `.env.development` and `.env.production` files in the frontend directory.\n   - Define `REACT_APP_API_BASE_URL` in these files (e.g., `http://localhost:8000` for development).\n   - Refactor all `fetch` or `axios` calls within the components developed in Task #28 and #49 to use `process.env.REACT_APP_API_BASE_URL` instead of a hardcoded URL.\n\n3. **Documentation:**\n   - Update the `README.md` file with a new 'Configuration' section.\n   - This section must explain how to copy `.env.example` to `.env` and set the required variables for local development.\n<info added on 2025-08-24T14:20:23.639Z>\n**Update based on code analysis:** A recent audit has identified several specific areas where hardcoded values must be externalized into the new configuration system. These include:\n- **API Endpoints:** Hardcoded `http://localhost:8000` in frontend API calls.\n- **Financial Constants:**\n  - Maximum loan limits (e.g., `300000`).\n  - Crop cost ranges (e.g., `23000` to `38000`).\n  - Pest/disease treatment costs (e.g., `3000`).\n  - Hardcoded market price assumptions used in agent logic.\n- **CORS Configuration:** Overly permissive wildcard settings (`\"*\"`) must be replaced with a configurable, comma-separated list of allowed origins.\n- **System Thresholds:** Any other magic numbers defining agent behavior or system limits.\n</info added on 2025-08-24T14:20:23.639Z>",
        "testStrategy": "1. **Development Environment Verification:**\n   - With a correctly configured `.env` file, run the backend and frontend locally.\n   - Verify the backend connects to the specified development database (e.g., SQLite) by checking startup logs.\n   - Verify the frontend successfully makes API calls to the local backend (`localhost:8000`) and the application is fully functional.\n   - Intentionally provide an incorrect database URL in `.env` and confirm the application fails to start with a clear error message.\n\n2. **Production Simulation Test:**\n   - Without a `.env` file, run the backend server by exporting environment variables directly in the shell (e.g., `export DATABASE_URL='postgresql://user:pass@host/db'`).\n   - Check the application logs to confirm it is using the production settings (e.g., attempting to connect to PostgreSQL).\n   - Run `npm run build` for the React app and serve the production build. Use browser developer tools to confirm API requests are directed to the URL specified in `.env.production`.\n\n3. **Code Review:**\n   - Perform a codebase search for hardcoded values like 'localhost', '8000', specific database paths, and known financial/system thresholds to ensure they have all been replaced by configuration variables.",
        "status": "in-progress",
        "dependencies": [
          26
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implement Regional Configuration for Agricultural Constants",
        "description": "Create a system to manage and load region-specific agricultural constants (e.g., crop costs, loan limits, market prices) for different Indian states, ensuring agents provide geographically relevant advice.",
        "details": "This task involves creating a flexible configuration system that allows the application to use different economic and agricultural parameters based on the user's geographical location.\n\n1. **Configuration File Structure:**\n   - Create a new directory in the backend, such as `app/configs/regions/`.\n   - Inside this directory, create JSON or YAML files for each supported region/state (e.g., `punjab.json`, `maharashtra.json`).\n   - Create a `default.json` file to serve as a fallback for regions without a specific file or for constants missing in a regional file.\n\n2. **Configuration Schema:**\n   - Define a consistent schema for these files. Example for `punjab.json`:\n   ```json\n   {\n     \"region_name\": \"Punjab\",\n     \"currency\": \"INR\",\n     \"units\": {\n       \"area\": \"acre\",\n       \"weight\": \"quintal\"\n     },\n     \"crop_costs\": {\n       \"wheat\": {\n         \"seed_cost_per_acre\": 2000,\n         \"fertilizer_cost_per_acre\": 4500,\n         \"labor_cost_per_acre\": 5000\n       },\n       \"rice\": {\n         \"seed_cost_per_acre\": 1800,\n         \"fertilizer_cost_per_acre\": 5500,\n         \"labor_cost_per_acre\": 7000\n       }\n     },\n     \"loan_limits\": {\n       \"crop_loan_per_acre\": 50000\n     },\n     \"market_prices_default\": {\n       \"wheat_per_quintal\": 2125,\n       \"rice_per_quintal\": 2060\n     }\n   }\n   ```\n\n3. **Configuration Loading Service:**\n   - Develop a `RegionConfigService` in the backend.\n   - This service will have a method like `get_config(region: str)` which loads the configuration for the specified region.\n   - The user's region will be retrieved from their profile (created in Task 42).\n   - The service should intelligently merge the specific regional config with the `default.json` config, where regional values override default values.\n\n4. **Agent Integration:**\n   - Modify relevant agents (e.g., Market Timing Agent, and future financial planning agents) to use this `RegionConfigService`.\n   - Instead of using hardcoded values, agents will request constants like `config_service.get_value('crop_costs.wheat.seed_cost_per_acre')` for the user's region.",
        "testStrategy": "1. **Unit Tests:**\n   - Write unit tests for the `RegionConfigService`.\n   - Test that it correctly loads a specific regional file (e.g., `punjab.json`).\n   - Test the fallback mechanism: verify that if a key is missing in `punjab.json` but exists in `default.json`, the default value is returned.\n   - Test the case where a region file does not exist, ensuring the entire `default.json` configuration is used.\n\n2. **Integration Tests:**\n   - Create a mock user profile with a location set to 'Maharashtra'.\n   - Trigger an agent that depends on a regional constant (e.g., a query about rice cultivation costs).\n   - Assert that the agent's response is based on values from `maharashtra.json`.\n   - Change the mock user's location to an unsupported region and verify the agent's response uses values from `default.json`.\n\n3. **End-to-End Verification:**\n   - Once Task 42 is complete, manually create a user, set their location during onboarding, and ask a question related to regional costs.\n   - Verify the response reflects the correct regional data.",
        "status": "pending",
        "dependencies": [
          26,
          42,
          51
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Implement Environment-Based API Configuration for Frontend",
        "description": "Remove the hardcoded backend API URL (localhost:8000) from the frontend codebase and implement a robust environment-based configuration system for development, staging, and production environments.",
        "details": "1. **Environment File Setup**: In the root of the React frontend project, create environment-specific configuration files:\n   - `.env.development`: For local development. Set `REACT_APP_API_BASE_URL=http://localhost:8000/api`\n   - `.env.staging`: For the staging environment. Set `REACT_APP_API_BASE_URL=https://staging-api.example.com/api`\n   - `.env.production`: For the production environment. Set `REACT_APP_API_BASE_URL=https://api.example.com/api`\n   - `.env.example`: Create a template file to be committed to version control, documenting the required variables for new developers.\n2. **Refactor API Calls**: Systematically search the codebase for the hardcoded URL `http://localhost:8000` and replace it with the environment variable `process.env.REACT_APP_API_BASE_URL`.\n3. **Centralize API Client**: If not already in place, create a single, centralized API client instance (e.g., an Axios instance in `src/api/client.js`). This instance should be configured with the base URL from the environment variable. Ensure all application API calls use this central instance for consistency and maintainability.\n4. **Update Build Scripts**: Modify the `package.json` scripts to support building for different environments. This may require a package like `env-cmd` for non-standard environments like staging.\n   ```json\n   \"scripts\": {\n     \"start\": \"react-scripts start\",\n     \"build\": \"react-scripts build\",\n     \"build:staging\": \"env-cmd -f .env.staging npm run build\"\n   }\n   ```\n   *Note: Create React App automatically uses `.env.development` for `npm start` and `.env.production` for `npm run build`.*",
        "testStrategy": "1. **Development Verification**: Run `npm start` locally. Open the web application and use the browser's Network tab in developer tools. Confirm that all API requests are correctly sent to the URL specified in `.env.development` (e.g., `http://localhost:8000/api`).\n2. **Staging Build Verification**: Execute the staging build script (e.g., `npm run build:staging`). Serve the resulting `build` directory using a static server like `serve`. Access the application and verify through the Network tab that API requests are directed to the staging URL from `.env.staging`.\n3. **Production Build Verification**: Run the standard build script (`npm run build`). Serve the `build` directory and verify that API requests are directed to the production URL from `.env.production`.\n4. **Configuration Error Check**: Temporarily rename or remove `.env.development`. Restart the development server and confirm that the application either fails to start or logs a clear error message indicating the missing API configuration, preventing runtime failures.",
        "status": "pending",
        "dependencies": [
          26,
          28,
          51
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Implement Comprehensive Configuration Management System",
        "description": "Establish a unified configuration system to manage environment-specific (dev/staging/prod) and regional settings, replacing all hardcoded values across the application.",
        "details": "This task combines and expands on Tasks 51 and 52 to create a single, robust configuration solution.\n\n1. **Establish Unified Directory Structure**:\n   - Create a central `app/config` directory.\n   - Inside, create `environments/` for environment-specific files (`development.py`, `staging.py`, `production.py`) and `regions/` for regional data (`default.json`, `punjab.json`, `maharashtra.json`).\n\n2. **Environment Configuration (builds on Task 51)**:\n   - Utilize `pydantic-settings` to create a `Settings` class in `app/config/core.py`.\n   - This class will load variables from environment variables (`.env` files) and the corresponding environment file from `environments/` based on an `APP_ENV` variable.\n   - Variables to manage include: `DATABASE_URL`, API keys, `FRONTEND_URL`, `BACKEND_URL`, `CORS_ORIGINS`, and system thresholds like `AGENT_TIMEOUT_SECONDS`.\n   - Create an `.env.example` file in the project root to document all required environment variables.\n\n3. **Regional Configuration (builds on Task 52)**:\n   - The regional JSON files will store data like `loan_limits`, `crop_specific_costs`, `mandi_list`, and other state-specific agricultural data.\n   - `default.json` will contain fallback values for any key not present in a specific state's file.\n\n4. **Create a Central `ConfigService`**:\n   - Develop a singleton service that is initialized on application startup.\n   - It will first load the environment settings.\n   - It will provide a method, e.g., `get_regional_config(state: str)`, which loads the appropriate regional JSON file, merges it with the `default.json` fallback, and returns the configuration object. This will be used by agents requiring user-specific data.\n\n5. **Application-wide Refactoring**:\n   - Systematically replace all hardcoded values throughout the codebase (in agents, API endpoints, database connectors) with calls to the new `ConfigService`.",
        "testStrategy": "1. **Unit Tests**:\n   - Write unit tests for the `ConfigService`.\n   - Verify that it correctly loads settings from environment variables and the correct `environments/` file.\n   - Test the regional config loader: ensure it loads the correct state file (e.g., `punjab.json`), and correctly falls back to `default.json` for missing keys.\n   - Test that the application fails to start if a required environment variable (without a default) is missing.\n\n2. **Integration Tests**:\n   - Set `APP_ENV=production` and run the test suite. Verify the application attempts to connect to the production database URL defined in the config.\n   - Create mock user profiles for different states (requires Task 42). Write integration tests for agents (e.g., Market Timing Agent) that verify their output changes based on the mock user's state, confirming that the correct regional financial constants are being used.\n\n3. **CI/CD Pipeline Verification**:\n   - Ensure the CI/CD pipeline (Task 45) can inject different environment variables for staging and production deployments.\n   - Deploy to a staging environment and check logs to confirm that the staging configuration is loaded. Manually test an endpoint that relies on a regional setting to confirm functionality.",
        "status": "pending",
        "dependencies": [
          26,
          42,
          51,
          52
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Fix Security Vulnerabilities in Configuration",
        "description": "Address security issues including overly permissive CORS settings, hardcoded sensitive values, and implement proper environment-based security configurations",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          54
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Implement Dynamic Frontend API Configuration",
        "description": "Replace hardcoded API_BASE_URL in frontend with environment-based configuration that automatically detects development vs production environments",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          28,
          54
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Build Regional Agricultural Data Management System",
        "description": "Create regional data files for different Indian states containing state-specific loan limits, crop costs, market prices, and agricultural constants that agents can load dynamically",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          36,
          37,
          54
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-13T17:08:38.099Z",
      "updated": "2025-08-24T14:27:14.566Z",
      "description": "Tasks for master context"
    }
  }
}